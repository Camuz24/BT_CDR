#include <signal.h>
#include "headers.h"
#include <pthread.h>
#include <iostream>
#include <time.h>
#include <iomanip>

using namespace std;
motor Motor;
int dc = 0;

pidController Pid;
bool running = 1;
double targetCadence=0;
double target=0;
double actual_cadence=0;
double x;
int y;

cadenceblock Cadence;
BcmEncoder Encoder;

#define DEFAULT_LOOP_TIME_NS 1000000L

long timeStructToMs(timespec t) // transforms time as struct to a long integer (time in ms)
{
    long result;

    result = t.tv_sec*1000 + t.tv_nsec/1000000;

    return result;
}

long long timeStructTons(timespec t) // transforms time as struct to a long integer (time in ms)
{
    long long result;

    result = t.tv_sec*1000000000 + t.tv_nsec;

    return result;
}

timespec addition(timespec a, timespec b) {
    timespec r;

    if(a.tv_nsec + b.tv_nsec <= 999999999) {
        r.tv_nsec = a.tv_nsec + b.tv_nsec;
        r.tv_sec = a.tv_sec + b.tv_sec;
    }
    else {
        int c = (a.tv_nsec + b.tv_nsec)/1000000000;
        r.tv_nsec = a.tv_nsec + b.tv_nsec - 1000000000*c;
        r.tv_sec = a.tv_sec + b.tv_sec + c;
    }

    return r;
}

void *threadFunction(void* a) {

    //signal(SIGINT, myInterruptHandler);

    //readfromSM();

    struct timespec t_now;
    struct timespec t_next;
    struct timespec t_period;
    struct timespec t_wait;
    struct timespec pause_duration;


    unsigned long int loop_count = 0;

    // t_period defines duration of one "running" cycle (1 ms in this case)
    t_period.tv_sec = 0;
    t_period.tv_nsec = DEFAULT_LOOP_TIME_NS;

    // pause_duration defines duration of pause considered when a buttton is pressed (1 s in this case)

    clock_gettime( CLOCK_MONOTONIC, &t_next);


    // inizializzo variabili per calcolare la cadenza
    float angle = Encoder.getAngle();
    float angle_old = -1;
    float cadence;
    double filtered_cadence = 0;
    double filtered_cadence_old = 0;

   while(running) {

    Pid.off();

    t_next = addition(t_next, t_period); // update t_next (needed for usleep at the end)clock_gettime ( CLOCK_MONOTONIC, &t_now);

/*    if(loop_count%15000 == 0) 
    {
        cout << "Set DutyCycle:";
        cin >> dc;
        cout << "Running with DutyCicle = " << dc << "\n";
        Motor.setPwmMotor(dc);
        double pidController::PID(double target, double cadence)
    }        */

    if(loop_count%600 == 0) {

        if(angle_old == -1) //prima iterazione
        {
            angle_old = angle; //non viene calcolata la cadenza
        }

        else 
        {
            angle = Encoder.getAngle(); //leggo l'angolo dall'encoder
            cadence = (double)Cadence.computeCadence(angle_old, angle);
            filtered_cadence = Cadence.filterCadence(cadence, filtered_cadence_old);
            angle_old = angle;
            cout << "La cadenza attauale è di " << fixed << setprecision(2) << filtered_cadence << endl;    
        }
    }  

        loop_count++;

        clock_nanosleep ( CLOCK_MONOTONIC, TIMER_ABSTIME, &t_next, nullptr ); // waits until time t_next is reached

        // print t_now (just to check "running" cycle repeats with desired frequency)
        clock_gettime ( CLOCK_MONOTONIC, &t_now);
        //cout << "\nT running = " << t_now.tv_sec*1000 + t_now.tv_nsec/1000000 << "\n";
    }
}


void myInterruptHandler (int sig)
{
    cout<<"Pograms will be terminated in sequence.\n";
    Motor.stopMotor();
    exit(sig);
}

int main (void)
{
    Motor.initMotor();
    Motor.setPwmMotor(0);
    Encoder.initEncoder();

    while(1) //però non si uscirà mai da questo ciclo quindi non verrà mai raggiunto il thread -> meglio mettere un'interrupt (?)
    {
        if(GetKeyState(VK_UP) & 0x8000)
        {
            while(GetKeyState(VK_UP) & 0x8000);
            dc+=5;
            Motor.setPwmMotor(dc);
            cout<<"Running with DutyCicle = "<< dc << "\n";
        }

        //se viene premuta la freccia di sinistra diminuisco il DC
        else if(GetKeyState(VK_DOWN) & 0x8000)
        {
            while(GetKeyState(VK_DOWN) & 0x8000);
            dc-=5;
            Motor.setPwmMotor(dc);
            cout<<"Running with DutyCicle = "<< dc << "\n";
        }
    }
    // controllo se viene premuta la freccia di destra allora aumento il DC di 5
    

    signal(SIGINT, myInterruptHandler);

    pthread_t thread;
    pthread_create(&thread, NULL, threadFunction, nullptr);
    pthread_join(thread, NULL);
}
